import uuid from 'uuid'
import database from '../firebase/firebase'; 
// Basic steps for Action generators -- [1] component calls action generator;  [2] action generator returns object;  
    // [3] component dispatches object;  [4] redux store changes

// Basic steps for Action generators using Redux -- [1] component calls action generator;  [2] action generator returns FUNCTION;  
    // [3] component dispatches function;  [4] function runs (has the ability to dispatch other actions & do whatever it wants);  
    // Note:  Redux by default doesn't let you dispatch functions;  need to add middleware for this to work;  

// ADD_EXPENSE action generator
export const addExpense = (expense) => ({    // destructuring the args; default vals; {} if no object
    type: 'ADD_EXPENSE', 
    expense
});

// this returns what gets dispatched (usually an object, but returning a function here)
export const startAddExpense = (expenseData = {}) => {  // default to {} if expenseData not received
    // return gets called by Redux;  dispatch var allows us to use dispatch in the function 
    return (dispatch) => {      // this function only works because we setup the middleware using redux in configureStore.js
        const {     // destructure key properties from expenseData, could have also done this in the args list 
            description='', 
            note='', 
            amount=0, 
            createdAt = 0
        } = expenseData; 
        // we are writing data to Firebase via .push, waiting for that data to sync, & then writing to dispatch (to update Redux)  
        const expense = { description, note, amount, createdAt }; 
        return database.ref('expenses').push(expense).then((ref) => {      // .then gets called with reference that we can access via ref
            dispatch(addExpense({    // dispatch needed or redux store will never change;  redux changes show on website
                id: ref.key,    // id generated by Firebase & can be accessed via ref.key
                ...expense
            }));   
        })  // by returning promise chain here will allow us to add a .then() on where this is received (e.g. in expenses.test.js);  
    }; 
}

// REMOVE_EXPENSE action generator
export const removeExpense = ( {id } = {} ) => ({    // destructuring the args; default vals; {} if no object;  implicity returns object via {{...})
    type: 'REMOVE_EXPENSE', 
    id
});

// async action that will fetch the data & then return a function where we dispatch removeExpense  
export const startRemoveExpense = ( {id} = {} ) => {  // no arg needed as we'll be fetching expenses;  
    // return gets called by Redux;  dispatch var allows us to use dispatch in the function 
    return (dispatch) => {
        return database.ref(`expenses/${id}`)   // gets the specific expense from firestore; 
            .remove()               //  remove from firestore the found expense 
            .then(() => {           //  .then() is success function;  
                dispatch(removeExpense({id}));   // update Store to remove expense 
            }); 
    }
}  

// EDIT_EXPENSE action generator
export const editExpense = (id, updates) => ({
    type: 'EDIT_EXPENSE', 
    id, 
    updates
})

// async action that will fetch/update the data & then return a function where we dispatch editExpense  
export const startEditExpense = ( id, updates ) => {    // updates is an object 
    // return gets called by Redux;  dispatch var allows us to use dispatch in the function 
    return (dispatch) => {
        return database.ref(`expenses/${id}`)   // gets the specific expense from firestore; return needed so we can add .then() later
            .update(updates)       // update all fields in records provided;
            //.set(...updates)       // works as well;  instructor used .update though     
            .then(() => {           //  .then() is success function;  
                dispatch(editExpense(id, updates));   // update Store to edit expense 
            }); 
    }
}

// SET_EXPENSES
export const setExpenses = (expenses) => ({
    type: 'SET_EXPENSES', 
    expenses
})

// async action that will fetch the data & then dispatch setExpenses  
export const startSetExpenses = () => {  // no arg needed as we'll be fetching expenses;  
    // return gets called by Redux;  dispatch var allows us to use dispatch in the function 
    return (dispatch) => {
        return database.ref('expenses')   // create an array from database info using .once() & childSnapshot; 
            .once('value')              // get all the data at this location one time
            .then((snapshot) => {       // .then() is success function;  firebase documenation has more info on .val() & .foreach()
                const expenses = []; 
                snapshot.forEach((childSnapshot) => {
                    expenses.push({   //  basically creating an array of objects by iterating over Child snapshots;  .key is randomly generated id
                        id: childSnapshot.key, 
                        ...childSnapshot.val()  
                    })
                });    
                
                dispatch(setExpenses(expenses));   // setExpenses expects an array 
            }); 
    }
}  